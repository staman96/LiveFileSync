Μανωλάς Σταμάτιος 1115201400094 Προγραμματισμός Συστήματος Εργασία 2η

Γενικά:

	Έχω ακολουθήσει τις οδηγίες της εκφώνησης και είδα και κάποιες διορθώσεις που υπήρχαν στο φόρουμ. Το πρόγραμμα τρέχει
όπως αναφέρεται στην εκφώνηση ακριβώς με τα ίδια ορίσματα αλλά τα δέχεται σε οποιαδήποτε σειρά. Έχουν αρχικές τιμές
οπότε όποιο και να λείψει εκτός από αυτά που χρειάζονται(πχ ινπουτ φάκελος), η εκτέλεση γίνεται κανονικά. Απλά τα αρχεία 
πρέπει να είναι τοπικά στο working directory γιατί αλλιώς δε τρέχει. Θεωρώ πως έχω υλοποιήσει όλα τα ζητήματα της εκφώνησης,
έχω τις αμφιβολίες μου για το πόσο καλά πιάνονται τα διάφορα έρρορς, γιατί δεν είχα χρόνο να δοκιμάσω τα σήματα σε ειδικές
περιπτώσεις, αλλά νομίζω καλύπτω αυτά που αναφέρονται στην εκφώνηση. Δεν πρόλαβα να ασχοληθώ με το μπόνους ερώτημα. Επίσης,
έτρεξα valgrind και κάπου χάνω έναν int σε bytes όσα και οι πελάτες που συνδέονται, αλλά όχι σε όλα τα processes. Το valgrind στα
linux της σχολής μου έβγαζε 0 έρρορς και χαμένα όλα τα δεδομένα.

Ανάπτυξη Κώδικα

get_stats.sh: 
	Τρέχει και τυπώνει όπως αναφέρεται στην εκφώνηση. Τίποτα σπουδαίο εκτός απο το shift που έκανα ώρα να βρω για να περνάω
πίνακα και μεταβλητές σε συνάρτηση.

create_infiles.sh:
	Εδώ ακολούθησα ακριβώς τα βήματα της εκφώνησης, στο βήμα 3 κατάλαβα ότι πρέπει να αποθηκεύω τα ονόματα σε πίνακα και αυτό 
έκανα.Και στο 5 χρησιμοποίησα round-robin. Να αναφερθεί ότι χρησιμοποίησα κώδικα από το stackoverflow στον έλεγχο του input.
https://stackoverflow.com/questions/806906/how-do-i-test-if-a-variable-is-a-number-in-bash?page=1&tab=votes#tab-top

mirror_client:
	
	Η γενική εικόνα έχει ως εξής, υπάρχουν 3 επίπεδα διεργασιών για κάθε mirror_client. Ο πατέρας διεργασία, μία ενδιάμεση
διεργασία πατέρα(intermediate), και τα παιδιά(child). Με αυτή τη λογική έχει χωριστεί και ο κώδικας, δηλαδή στη κλάση child
έχει κωδικά που τρέχει μόνο για τα παιδιά, στην interparent για τον ενδιάμεσο γονέα και τις αποδεσμεύσεις μόνο στα παιδιά,
και στη main και στο commonIDs κάθεται μόνο η αρχική διεργασία και οι υπόλοιπες περνάνε μόνο τις αποδεσμεύσεις. 
	Η λειτουργία της αρχικής διεργασίας είναι να ελέγχει τα ορίσματα και όποτε άλλοι πελατες στο "δίκτυο" να ξεκινάει μια
ενδίαμεση διεργασία για κάθε πελάτη. Αν ενας πελάτης φύγει να ξεκινάει μια διεργασία που να διαγράφει τα αντίστοιχα αρχεία 
από το τοπικό mirror directory. Είναι εξολοκλήρου NON BLOCKING.
	Η ενδιάμεση διεργασία είναι BLOCKING και περιμένει τα 2 παιδιά που κάνει fork για την αποστολή και τη παραλαβή. Είναι
υπέυθυνη για τα pipes αποστολής μόνο(ο πελάτης θα φτιάξει δικό του αποστολής), για το signal handling των παιδιών και να 
βάζει στο log αρχείο τους πελάτες με τους οποίους επικοινώνησε ομαλά.
	Τα παιδιά στέλνουν και δέχονται αρχεία και φακέλους σε ένα πελάτη.
ΕΙΔΙΚΟΤΕΡΑ:
	Η αρχική διεργασία κάθε δευτερόλεπτο ψάχνει να βρει καινούργιους πελάτες και έπειτα πελάτες που αποχώρησαν. Όταν βρει 
καινούργιους πελάτες μέσω της commonIDs, ανοίγει μια ενδιάμεση διεργασία για κάθε πελάτη και αποθηκεύει σε λίστα το process
id της ενδιάμεσης ώστε όταν θα λαβει SIGINT ή SIGQUIT σήμα να ελέγξει αν όλες οι ενδιάμεσες έχουν τελειώσει, κι όποια τρέχει 
να τη σκοτώσει. Όσον αφορά τη διεργασία που φτιάχνει για να κάνει διαγραφή τα αρχεία ενός πελάτη που έφυγε, άπλα τρέχει
από το child.cpp τη static function removeALL() που διαγράφει αναδρομικά οτιδήποτε υπάρχει κάτω από το directory που δέχεται
ως όρισμα. Τέλος, διαγράφει όλα τα δεδομένα της κατά την έξοδο, συμπεριλαμβανομένου και του mirror_directory της!!!!
	Η ενδιάμεση διεργασία όταν ξεκινήσει φτιάχνει τα pipes αν δεν υπάρχουν, αλλιώς τα διαγράφει και τα ξαναφτιάχνει, ουτως
ώστε αν υπάρξει επαναληπτική επικοινωνία, λόγω λάθους της προηγούμενης, να γίνεται σε καθαρα pipes. Επίσης, η πρώτη απόπειρα
μεταφοράς μετράει ως τη 1η δοκιμή και συνολικά μπορεί να φτάσει τις 3 δοκιμές. Στη κατάσταση αναμονής, αν και τα 2 παιδιά 
τελειώσουν ομαλά τυπώνεται αντίστοιχο μύνημα. Αν ληφθεί έρρορ για κάποιο τυχαίο πρόβλημα από ένα απο τα 2 παιδιά σκοτώνει
το άλλο και ξαναδοκιμάζει τη μεταφορά. Αν το έρρορ είναι λόγω μπλοκαρίσματος κάποιου παιδιού στα pipes για πάνω απο 30
δευτερόλεπτα, σκοτώνει το άλλο παιδί, σταματάει η μεραφορά και το ενδιάμεσο process τερματίζει με λάθος.
	Τα παιδιά έχουν την εξής λειτουργία:
	Η διεργασία αποστολέας δέχεται έναν πελάτη, ανοίγει το pipe και ξεικινάει να στέλνει. Ουσιαστικά, γίνεται αποστολή 
αρχείων και ονομάτων φακέλων σε μορφή δείκτη. Δηλαδή, ο αποστολέας όταν στέλνει φάκελο λέει στο δέκτη δημιουργησε το φάκελο
και μπες μεσα ή βγές έξω. Το πρωτόκολλο επικοινωνίας αποτελείται από 4 κομμάτια:
	-> 2 bytes που δηλώνουν το μήκος του ονόματος  
	-> όνομα του αρχείου ή φακέλου
	-> 4 bytes που δηλώνουν το μήκος του αρχείου, ή αν είναι 1 φτιάξε φακελο με το όνομα και μπες μέσα, ή αν είναι 2,
		πηγαινε ένα φάκελο πίσω(εφόσον τα αρχεία είναι τουλάχιστον 1000 bytes, ο τρόπος αυτός δουλεύει)
	-> το δεδομένα τα αρχείου, αλλιώς το μέρος αυτό δεν υπάρχει.
	Πλησίαζει το send depth first.
Η αποστολή όλων των αρχείων και των δεδομένων γίνεται πάνω από 1 pipe.(και άλλο 1 για τη λήψη)
Όταν ο αποστολέας τελειώσει στέλνει σαν μήκος ονόματος 0. Γενικά γύρω από τα pipes έχω βάλει alarms 30  δευτερολέπτων που
όποτε υπάρξει αποστολή ή λήψη ακυρώνεται. Ο αποστολέας για να στείλει τα δεδομένα ενός αρχείου το σπάει σε κομματια με το
buffer και τα στελνει. 
Το σημαντικό σημείο στον παραλήπτη είναι οτι διαβάζει από το pipe με το buffer και αφαιρεί όσα bytes κατάφερε να διαβασει,
μέχρι που θα του μείνει ένα μιροτερο κομματι από το μέγεθος του buffer, και τότε μπαίνει σε αλλη επαναληψη με μεταβλητό 
buffer ώστε να διαβάσει ακριβώς όσα bytes απέμειναν. Και αυτό το μέρος ελέγχεται με alarms γιατί μπορεί να διαβάζει για
κάποιο χρονικό διάστημα 0 bytes.
	Τέλος, στο log file καταγράφονται πόσοι πελάτες συνδέθηκαν και αποσυνδέθηκαν, πόσα bytes από αρχεία και πόσα bytes 
από ονόματα αρχείων και φακέλων στάλθηκαν και λήφθηκαν. Επίσης, τη λίστα τη πήρα από προηγούμενη εργασία.
